// 上一个挑战的问题出在 tabClose() 函数里的 splice。 不幸的是，splice 修改了调用它的原始数组，所以第二次调用它时是基于修改后的数组，才给出了意料之外的结果。

// 这是一个小例子，还有更广义的定义——在变量，数组或对象上调用一个函数，这个函数会改变对象中的变量或其他东西。

// 函数式编程的核心原则之一是不改变任何东西。 变化会导致错误。 如果一个函数不改变传入的参数、全局变量等数据，那么它造成问题的可能性就会小很多。

// 在函数式编程中，改变或变更叫做 mutation，这种改变的结果叫做“副作用”（side effect）。 理想情况下，函数应该是不会产生任何副作用的 pure function。

// 让我们尝试掌握这个原则：不要改变代码中的任何变量或对象

// 传递参数以避免函数中的外部依赖

// 函数式编程的另一个原则是：总是显式声明依赖关系。 如果函数依赖于一个变量或对象，那么将该变量或对象作为参数直接传递到函数中。

// 这样做会有很多好处。 其中一点是让函数更容易测试，因为你确切地知道参数是什么，并且这个参数也不依赖于程序中的任何其他内容。

// 其次，这样做可以让你更加自信地更改，删除或添加新代码。 因为你很清楚哪些是可以改的，哪些是不可以改的，这样你就知道哪里可能会有潜在的陷阱。

// 最后，无论代码的哪一部分执行它，函数总是会为同一组输入生成相同的输出。

// 全局变量
let fixedValue = 4;

// 只修改这一行下面的代码
function incrementer(val) {
  return val + 1;
  // 只修改这一行上面的代码
}
console.log(incrementer(fixedValue)); // 5
